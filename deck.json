{
    "__type__": "Deck",
    "children": [
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "269e0b9a-65a7-11f0-9d2d-2cf05d74b1f3",
            "deck_config_uuid": "2693157b-65a7-11f0-9870-2cf05d74b1f3",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "Chapters",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [],
            "reviewLimit": null,
            "reviewLimitToday": null
        }
    ],
    "crowdanki_uuid": "7b60bb6b-65a9-11f0-bfc7-2cf05d74b1f3",
    "deck_config_uuid": "2693157b-65a7-11f0-9870-2cf05d74b1f3",
    "deck_configurations": [
        {
            "__type__": "DeckConfig",
            "answerAction": 0,
            "autoplay": true,
            "buryInterdayLearning": false,
            "crowdanki_uuid": "2693157b-65a7-11f0-9870-2cf05d74b1f3",
            "desiredRetention": 0.9,
            "dyn": false,
            "easyDaysPercentages": [
                1.0,
                1.0,
                1.0,
                1.0,
                1.0,
                1.0,
                1.0
            ],
            "fsrsParams5": [],
            "fsrsWeights": [],
            "ignoreRevlogsBeforeDate": "",
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.0
            },
            "maxTaken": 60,
            "name": "Default",
            "new": {
                "bury": false,
                "delays": [
                    1.0,
                    10.0
                ],
                "initialFactor": 2500,
                "ints": [
                    1,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 20
            },
            "newGatherPriority": 0,
            "newMix": 0,
            "newPerDayMinimum": 0,
            "newSortOrder": 0,
            "questionAction": 0,
            "replayq": true,
            "rev": {
                "bury": false,
                "ease4": 1.3,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "perDay": 200
            },
            "reviewOrder": 0,
            "secondsToShowAnswer": 0.0,
            "secondsToShowQuestion": 0.0,
            "sm2Retention": 0.9,
            "stopTimerOnAnswer": false,
            "timer": 0,
            "waitForAudio": true,
            "weightSearch": ""
        }
    ],
    "desc": "",
    "dyn": 0,
    "extendNew": 0,
    "extendRev": 0,
    "media_files": [
        "paste-07d208c7b6cb054dcc4759ae357de1b53be594f7.jpg",
        "paste-da0452d964866a07cb34f37ca7574279216a426a.jpg"
    ],
    "name": "Compiler Design",
    "newLimit": null,
    "newLimitToday": null,
    "note_models": [
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "css": ".card {\n    font-family: arial;\n    font-size: 20px;\n    text-align: center;\n    color: black;\n    background-color: white;\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": 4011255275627962864,
                    "name": "Front",
                    "ord": 0,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": -6208914048281191020,
                    "name": "Back",
                    "ord": 1,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Basic",
            "originalStockKind": 1,
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tmpls": [
                {
                    "afmt": "{{FrontSide}}\n\n<hr id=answer>\n\n{{Back}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "id": 2953996692468982584,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "{{Front}}"
                }
            ],
            "type": 0
        }
    ],
    "notes": [
        {
            "__type__": "Note",
            "fields": [
                "Name each phase of the Compiler W<br><img src=\"paste-07d208c7b6cb054dcc4759ae357de1b53be594f7.jpg\">",
                "<img src=\"paste-da0452d964866a07cb34f37ca7574279216a426a.jpg\">"
            ],
            "guid": "NE8zC8kDHN",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "Overview"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is instruction selection in compiler design?",
                "Instruction selection is the compiler phase that transforms intermediate code (IR) into abstract assembly instructions, bridging the gap between high-level language constructs and machine code."
            ],
            "guid": "bkopx-ihW0",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are IR trees in compiler design?",
                "IR Trees are a structured intermediate representation of programs using trees for expressions. Each node represents an operation or operand."
            ],
            "guid": "O/h.MQX%TB",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What kind of statements and expressions can IR trees contain?",
                "Assignments and return statements; expressions can include constants, temps (variables), and binary operations like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>.<br><strong><br>Expressions</strong> are recursive: their code is generated <strong>bottom-up</strong>, combining sub-expressions.<br><br><b>Statements</b> are top-down: they <em>use</em> expressions and translate into instructions with side-effects (like storing results or jumping)."
            ],
            "guid": "D,33}129DU",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the maximal munch algorithm?",
                "The compiler searches for the <strong>largest matching subtree</strong>, not just the immediate node."
            ],
            "guid": "i~.K->DkpK",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In maximal munch, why is pattern order important?",
                "To prioritize more efficient instruction patterns (like using a shift for multiplication by 2) before falling back to general ones (like generic multiplication)."
            ],
            "guid": "yLjhDqXA*S",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does&nbsp;ˇe and&nbsp;ˆe mean in code generation",
                "ˇe (e check) denotes the instruction sequence implementing expression <code>e</code>.<br><div>ˆe (e hat) denotes the operand (e.g., a temp) that holds the result of evaluating expression <code>e</code>.</div>"
            ],
            "guid": "A,-CyeO.@6",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is strength reduction in instruction selection?",
                "An optimization that replaces expensive operations with cheaper ones, e.g., using a shift instead of multiplication by 2."
            ],
            "guid": "d1rIm/t}t?",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Give an example of strength reduction used in instruction selection.",
                "Replace <code>e * 2</code> with <code>t ← e &lt;&lt; 1</code>."
            ],
            "guid": "pYTCH7BUZo",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Given the source: <code>z = (x + 3) * (y - 5); return z</code>, what abstract assembly is generated?",
                "t1 ← x + 3&nbsp; <br>t2 ← y − 5&nbsp; <br>z ← t1 * t2&nbsp; <br>rret ← z"
            ],
            "guid": "w-B5o78g+X",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is constant propagation in instruction selection?",
                "Replacing uses of a temp assigned to a constant (<code>t ← 5</code>) with the constant directly, unless <code>t</code> is reassigned later."
            ],
            "guid": "LST6Q8}UXV",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is copy propagation in instruction selection?",
                "Replacing uses of a temp (<code>t ← x</code>) with the original variable <code>x</code>, unless either <code>t</code> or <code>x</code> is reassigned."
            ],
            "guid": "p9cc<@^Szf",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "When is copy propagation unsafe?",
                "<div>When the original variable (<code>x</code>) is reassigned before the temp is used.</div>"
            ],
            "guid": "CF}8)*Y;;S",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is Static Single Assignment (SSA) form?",
                "A representation where each variable (temp) is assigned exactly once, often by appending a version number (e.g., <code>t0</code>, <code>t1</code>)."
            ],
            "guid": "BcWd1m`_ew",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does SSA simplify optimization?",
                "Each temp has one assignment, so you can safely replace its uses with its assigned value without tracking reassignments."
            ],
            "guid": "um~;`{VEyn",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Convert this code to SSA:<br>t ← 5&nbsp; <br>x ← t - 4&nbsp; <br>t ← t + x&nbsp; <br>z ← t - 1",
                "t0 ← 5&nbsp; <br>x0 ← t0 - 4&nbsp; <br>t1 ← t0 + x0&nbsp; <br>z0 ← t1 - 1"
            ],
            "guid": "N<EkCcB#YY",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How are 3-address instructions emulated on x86-64 (which has 2-address instructions)?",
                "Split the 3-address operation into a move followed by a 2-address operation.<br>\nExample:<br>d ← s1 + s2 becomes:&nbsp; <br>d ← s1&nbsp; <br>d ← d + s2"
            ],
            "guid": "GNC+GAh[u+",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How is integer division implemented on x86-64?",
                "MOVL s1, %eax&nbsp; <br>CLTD&nbsp; <br>IDIVL s2&nbsp; <br>MOVL %eax, d"
            ],
            "guid": "pdKsc,>(c4",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why is the <code>CLTD</code> instruction needed before <code>IDIVL</code>?",
                "It sign-extends %eax into %edx to prepare for 64-bit division (dividend is [%edx,%eax])."
            ],
            "guid": "M#6%LW.HS5",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How can you implement the data structures for an intermediate representation as defined in this lecture?",
                "Use class hierarchies to represent IR nodes like constants, variables, and binary operations. These form expression trees that can be traversed for instruction selection."
            ],
            "guid": "bjp$d9PQa?",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection",
                "quiz"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the advantages and disadvantages of a 3-address intermediate representation?",
                "<div><strong>Advantages:</strong></div>\n<ul>\n<li>\n<div>Cleaner separation of operands and result</div>\n</li>\n<li>\n<div>Easier for optimizations</div>\n</li></ul><strong>Disadvantages:</strong><br><ul>\n<li>\n<div>Requires more temporaries and registers</div></li></ul>"
            ],
            "guid": "ue.v!3M`C6",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection",
                "quiz"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are the advantages /&nbsp;disadvantages of using <b>macro expansion</b> for instruction selection?",
                "<div><strong>Advantages:</strong></div>\n<ul>\n<li>\n<div>Simplicity and modularity — each IR construct maps to a fixed instruction sequence.</div></li></ul><b>Disadvantages:</b><br><ul><li>Inefficient code due to lack of context-aware optimizations; leads to redundant instructions and missed optimizations.</li></ul>"
            ],
            "guid": "zim(`-2h{C",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "instruction_selection",
                "quiz"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is register allocation in compilers?",
                "Mapping unbounded temps in pseudo-assembly to a limited number of CPU registers."
            ],
            "guid": "Nl)#&1[,Ad",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why not spill all variables to memory like in JVM?",
                "Memory access is slower than registers, degrading performance."
            ],
            "guid": "dc,A,Q,3R(",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "When are two variables said to interfere?",
                "When their live ranges overlap—they must be assigned different registers."
            ],
            "guid": "wyp-lHQx[Y",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What does a node represent in the interference graph?",
                "A variable (or register)."
            ],
            "guid": "tCbPR`lA:;",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How is liveness determined in a straight-line program?",
                "By traversing backward and marking used variables until redefined."
            ],
            "guid": "N~:V[;w0%*",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the register allocation problem reduced to in Graph Coloring?",
                "K-coloring of the interference graph where adjacent nodes have different colors."
            ],
            "guid": "GDfd)4N@B&",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What happens if the graph isn’t K-colorable?",
                "Spilling is needed—some variables are stored in memory."
            ],
            "guid": "Q6hSpQ[Zg~",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What defines a chordal graph?",
                "Every cycle of 4+ nodes has a chord—an edge between non-consecutive nodes in the cycle."
            ],
            "guid": "M;J]_y*&>o",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why are chordal graphs important in register allocation?",
                "They allow efficient optimal coloring using simplicial elimination ordering."
            ],
            "guid": "E9|Re<K1gp",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a simplicial node?",
                "A node whose neighbors form a clique."
            ],
            "guid": "w5jN7[VC}p",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What algorithm finds Simplicial Elimination Ordering efficiently?",
                "Maximum Cardinality Search (MCS), in O(|V| + |E|) time."
            ],
            "guid": "G$E!4^9.z&",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does greedy coloring work?",
                "Colors nodes in order, assigning the lowest available color not used by neighbors."
            ],
            "guid": "H:OG8m6X&~",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the maximum number of colors greedy coloring will use?",
                "Δ(G) + 1, where Δ(G) is the maximum degree in the graph."
            ],
            "guid": "cw+0(^j(3?",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is register spilling?",
                "Saving variables to memory when there are not enough registers."
            ],
            "guid": "s4[BmI}P0_",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How do you rewrite code for spilled variables?",
                "Use reserved registers (e.g., %r11) to load/store from memory."
            ],
            "guid": "n_d$_sXz<V",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is register coalescing?",
                "Optimization to eliminate register-to-register moves if no interference exists."
            ],
            "guid": "wBP4siUyr]",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is a precolored node in register allocation?",
                "A variable assigned to a specific hardware register (e.g., %eax for return values)."
            ],
            "guid": "G4=sb6/E_y",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "register_allocation"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "When is a variable considered \"live\" in liveness analysis?",
                "A variable is live at a program point if it may be used in the future before being overwritten."
            ],
            "guid": "dSzlTw(n@1",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why is liveness analysis important in compiler design?",
                "It's essential for register allocation. It helps determine when variables can share registers without conflict."
            ],
            "guid": "A6<0*#PTWz",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is liveness analysis decidable?",
                "No, it's undecidable in general for Turing-complete languages, but approximations (like the one presented) are used."
            ],
            "guid": "uH+b>3,^e8",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the difference between 'live-in' and 'live-out' in liveness analysis?",
                "'Live-in' means variables are live at the beginning of the instruction. 'Live-out' means variables are live after the instruction."
            ],
            "guid": "A15@0MG&H^",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is saturation in the context of inference rules?",
                "It means applying all inference rules until no new facts can be derived."
            ],
            "guid": "BG|Af-D3W{",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In the rule <code>x ← y ⊕ z</code>, which variables are live at this instruction?",
                "<div>y and z (used), and any variables live in the next instruction except x.</div>"
            ],
            "guid": "I8q:!8ppZ;",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What is the inference rule L1 and L2?",
                "If <code>x ← y ⊕ z</code> occurs at line l, then <code>live(l, y)</code> and <code>live(l, z)</code>.<br>If <code>x ← y ⊕ z</code> at line l and <code>u</code> is live at <code>l+1</code> and <code>u ≠ x</code>, then <code>u</code> is live at <code>l</code>."
            ],
            "guid": "C=Dw^f!P[W",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In <code>return x</code>, which variable is live?",
                "Only x."
            ],
            "guid": "b#UEKhZ@vi",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does <code>goto l'</code> affect liveness?",
                "Any variable live at <code>l'</code> is also live at the <code>goto</code> line."
            ],
            "guid": "v>f^0X]EXF",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What variables are live at a conditional <code>if (x ∼ c) goto l'</code>?",
                "x is live; any variable live at <code>l+1</code> or at <code>l'</code> is also live at the current line."
            ],
            "guid": "cKKT?&Zdvb",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What's the significance of refactoring rules with <code>use</code>, <code>def</code>, and <code>succ</code> predicates?",
                "It abstracts repetitive inference patterns and simplifies rule structure."
            ],
            "guid": "LC6:d#}F^F",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What are rule K1 and K2?",
                "K1: If <code>use(l, x)</code> then <code>live(l, x)</code>.<br>K2: If <code>u</code> is live at successor <code>l'</code>, and <code>u</code> is not defined at line <code>l</code>, then <code>u</code> is live at <code>l</code>."
            ],
            "guid": "w(<8L[}pgP",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In a straight-line program, why is backward propagation precise for liveness?",
                "Because there's only one control flow path; no need to consider multiple branches or loops."
            ],
            "guid": "nrqmac~5W$",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In loops, why do we need multiple passes to compute liveness?",
                "Because of backward jumps; liveness can propagate back only after knowing what’s live in the loop body."
            ],
            "guid": "su}mYfO9Kw",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How can z interfere with other variables even if it's dead code?",
                "If z is assigned but unused, it still interferes with other variables live on the same line due to register allocation."
            ],
            "guid": "PP/6^3xh+r",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What's the difference between liveness and neededness?",
                "Liveness tracks future use; neededness tracks whether a value affects program output. Neededness is used in dead code elimination."
            ],
            "guid": "dL8:@XOOkw",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Given the instruction <code>x ← y + z</code> at line 5, and <code>live(6, x)</code>, is x live at line 5? Why or why not?",
                "No, because x is being overwritten at line 5."
            ],
            "guid": "DjOb%SD`i.",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Write out the inference rules needed to determine liveness for a conditional jump.",
                "L6, L7, and L8. L6 adds x as live, L7 and L8 propagate live vars from both successors (l+1 and l')."
            ],
            "guid": "Hi:i?^wPa.",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In a program with loops, how do you know when liveness saturation is complete?",
                "When applying the inference rules no longer produces any new <code>live(l,x)</code> facts."
            ],
            "guid": "nY|Dr9{P-P",
            "note_model_uuid": "7b60bb6f-65a9-11f0-9668-2cf05d74b1f3",
            "tags": [
                "liveness_analysis"
            ]
        }
    ],
    "reviewLimit": null,
    "reviewLimitToday": null
}